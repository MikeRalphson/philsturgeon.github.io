<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <!-- (1) Optimize for mobile versions: http://goo.gl/EOpFl -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- (1) force latest IE rendering engine: bit.ly/1c8EiC9 -->
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <title>GraphQL vs REST: Overview | Phil Sturgeon</title>
  <meta name="description" content="Platform Engineer @ WeWork who talks about APIs a lot. Programming Polyglot, Pragmatist, Centerist and Sarcasist. Ex-The League of Extraordinary Packages, PHP The Right Way, Ex-PHP-FIG, Ex-CodeIgniter, Ex-FuelPHP, Ex-PyroCMS." />

  <meta name="HandheldFriendly" content="True" />
  <meta name="MobileOptimized" content="320" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <link rel="stylesheet" href="//brick.a.ssl.fastly.net/Linux+Libertine:400,400i,700,700i/Open+Sans:400,400i,700,700i">
  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">

  <link href="/stylesheets/main.css" rel="stylesheet" media="screen" />
  <link href="/stylesheets/print.css" rel="stylesheet" media="print" />
  <link href="/images/favicon.jpg" rel="icon" type="image/jpg" />

  <meta property="og:title" content="GraphQL vs REST: Overview" />
  <meta property="og:type" content="article" />
  <meta property="article:author" content="Phil Sturgeon" />
  <meta property="og:description" content="A few months back I wrote a comparison between RPC and REST for Smashing Magazine, and now I want to talk about the differences between REST and GraphQL: the new kid on the block." />
  <meta property="og:site_name" content="Phil Sturgeon" />
  <meta property="og:image" content="https://philsturgeon.uk/images/author.jpg" />
  <meta property="og:url" content="https://philsturgeon.uk/api/2017/01/24/graphql-vs-rest-overview/" />
  <meta property="og:locale" content="en_GB" />

  <meta name="twitter:card" content="summary">
  <meta name="twitter:site" content="@philsturgeon">
  <meta name="twitter:title" content="GraphQL vs REST: Overview | Phil Sturgeon">
  <meta name="twitter:image:src" content="https://philsturgeon.uk/images/author.jpg">
  <meta name="twitter:url" content="https://philsturgeon.uk/api/2017/01/24/graphql-vs-rest-overview/">
  <meta name="twitter:description" content="A few months back I wrote a comparison between RPC and REST for Smashing Magazine, and now I want to talk about the differences between REST and GraphQL: the new kid on the block.">
  <meta name="twitter:creator" content="@philsturgeon">

  <link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/feed.xml" />
</head>


  <body>

    <a class='fa fa-home logo-readium' href='/'></a>


    <!-- content start -->

    <main class="content" role="main">
      <article class="post">
        <div class="noarticleimage">
          <div class="post-meta">
            <h1 class="post-title">GraphQL vs REST: Overview</h1>
            <div class="cf post-meta-text">
              <div class="author-image" style="background-image: url(/images/author.jpg)">Blog Logo</div>
              <h4 class="author-name" itemprop="author" itemscope itemtype="http://schema.org/Person">Phil Sturgeon</h4>
              on
              <time datetime="2017-01-24 22:16:00 UTC">
                Jan 24 2017
              </time>
              <a href="/tag/graphql/">#graphql</a>
              <a href="/tag/rest/">#rest</a>
              <a href="/tag/api/">#api</a>
              <a href="/tag/http/">#http</a>
            </div>
          </div>
        </div>
        <br>
        <br>
        <br>
        <section class="post-content">
          <div class="post-reading">
            <span class="post-reading-time"></span> read
          </div>
          <a name="topofpage"></a>
          <hr>

          <p>A few months back I wrote <a href="https://www.smashingmagazine.com/2016/09/understanding-rest-and-rpc-for-http-apis/">a comparison between RPC and REST</a> for Smashing Magazine, and now I want to talk about the differences between REST and GraphQL: the new kid on the block.</p>

<p><a href="http://graphql.org/">GraphQL</a> is incorrectly considered by some to be a "replacement" to <a href="https://en.wikipedia.org/wiki/Representational_state_transfer">REST</a>. GraphQL is a newer concept, being released by Facebook publicly in 2015, whereas REST was a <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm">dissertation</a> published by Roy Fielding in 2000, popularized by companies like Twitter (quite inaccurately) in 2006.</p>

<p>This article aims to cover a few notable differences, and make the following points:</p>

<ol>
  <li>REST and GraphQL are totally different</li>
  <li>GraphQL isn't a magic bullet, nor is it "better"</li>
  <li>You can definitely use both at the same time</li>
  <li>GraphQL is dope <em>if used for the right thing</em></li>
</ol>

<h2 id="a-few-quick-differences">A few quick differences</h2>

<p>REST is an <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_3">architectural concept</a> for network-based software, has no official set of tools, has no specification, doesn't care if you use HTTP, AMQP, etc., and is designed to decouple an API from the client. The focus is on making APIs last for decades, instead of optimizing for performance.</p>

<p>GraphQL is a <a href="http://graphql.org/learn/queries/">query language</a>, <a href="http://facebook.github.io/graphql/">specification</a>, and <a href="https://github.com/graphql/">collection of tools</a>, designed to operate over a single endpoint via HTTP, optimizing for performance and flexibility.</p>

<p>One of the <a href="http://www.restapitutorial.com/lessons/whatisrest.html">main tenets of REST</a> is to utilize the uniform interface of the protocols it exists in. When utilizing HTTP, REST can leverage HTTP content-types, caching, status codes, etc., whereas GraphQL invents its own conventions.</p>

<p>Another main focus for REST is hypermedia controls (a.k.a <a title="Hypermedia As The Engine Of Application State" href="https://en.wikipedia.org/wiki/HATEOAS">HATEOAS</a>), which lets a well designed client run around an API like a human runs around the Internet; starting with a search for "How to complete my tax returns", reading a perfectly relevant article, and after a few clicks ending up on BuzzFeed article about Miley Cyrus throwing Liam Hemsworth a "Weed-Themed" birthday party.</p>

<p>If your API is not using hypermedia controls, then GraphQL could be a more relevant approach, because you <a href="https://www.martinfowler.com/articles/richardsonMaturityModel.html">weren't really using REST anyway</a>.</p>

<p>This article will not attempt to point out a winner, but we're going to look at a few areas where the two differ. Don't get mad that a lot of the sections say "it depends", because the winner in each section really depends on what your API is doing, and how. GraphQL comes out stronger in some areas, REST in others, and sometimes they're both kinda terrible. Let's dig in!</p>

<h2 id="is-the-api-more-than-data-transfer">Is the API More Than Data Transfer?</h2>

<p>One of the most common tasks REST APIs provide is <abbr title="Create, Read, Update &amp; Delete">CRUD</abbr> via JSON, but it can do plenty more than that, such as <a href="/api/2016/01/04/http-rest-api-file-uploads/">file uploads</a>.</p>

<p>Uploading an image in the HTTP body can look a little something like this:</p>

<pre class="highlight http"><code><span class="nf">POST</span> <span class="nn">/avatars</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Host</span><span class="p">:</span> <span class="s">localhost:3000</span>
<span class="na">Content-Type</span><span class="p">:</span> <span class="s">image/jpeg</span>
<span class="na">Content-Length</span><span class="p">:</span> <span class="s">284</span>

raw image content
</code></pre>

<p>Leveraging a cool part of HTTP (and therefore REST), API developers can support <code>application/json</code> requests on the same endpoint to handle the upload slightly differently, and offer URL-based uploads too:</p>

<pre class="highlight http"><code><span class="nf">POST</span> <span class="nn">/avatars</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Host</span><span class="p">:</span> <span class="s">localhost:3000</span>
<span class="na">Content-Type</span><span class="p">:</span> <span class="s">application/json</span>

<span class="p">{</span><span class="w">
  </span><span class="nt">"image_url"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"https://example.org/pic.png"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre>

<p>Generally the APIs I have worked on have enjoyed both, which is super handy as iOS often sends photos directly from local files, and web clients often send a URL to the user's Facebook display picture.</p>

<p>If we were talking about uploading videos or other large files, I would (as <a href="/api/2016/01/04/http-rest-api-file-uploads/">this article suggests</a>) switch to another approach and have a dedicated service which handles the upload, leaving the main API to only accept metadata; title, description, tags, etc.</p>

<p>This is the approach you are forced to take with GraphQL, because you can only speak to GraphQL in terms of fields:</p>

<pre class="highlight http"><code><span class="nf">POST</span> <span class="nn">/graphql</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Host</span><span class="p">:</span> <span class="s">localhost:3000</span>
<span class="na">Content-Type</span><span class="p">:</span> <span class="s">application/graphql</span>

mutation addAvatar {
  addAvatarFromUrl(image_url: "https://example.org/pic.png") {
    id,
    image_url
  }
}
</code></pre>

<p>Some will argue that this is more "clean", and it is, it's very clean, but being forced to create another service is overkill for smaller images, especially early on. Another approach is to upload directly to Amazon S3, forcing a dependency on clients and potentially letting your tokens leak, orâ€¦ use multipart uploads, which are a super hacky approach that depends on if the server and various clients can even support it.</p>

<p>This is one area where REST holds strong. Some would say that REST handling CRUD and arbitrary stuff is confusing, but this is a core tenet of what makes REST so useful. A REST API can do anything, not just send fields backwards and forwards - even if that is how REST is often used.</p>

<h2 id="both-graphql-and-rest-prefer-evolution">Both GraphQL and REST Prefer Evolution</h2>

<p>One false advertised benefit of GraphQL I've seen suggested (in quite a few locations) is that you "never have to version anything."</p>

<p><img alt="How versioning works in GraphQL. (source: http://graphql.org/) " src="/images/article_images/2017-01-24-graphql-vs-rest-overview/graphql-versioning-marketing-site.gif" /></p>

<p>The suggested approach is to add new fields and deprecate old ones, which is <a href="https://www.mnot.net/blog/2012/12/04/api-evolution">a concept well known in REST as evolution</a>.</p>

<p>Deprecating, communicating to third-parties, monitoring usage, and removing at an acceptable time, is exactly what many REST APIs have been doing forever.</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">The reason to make a real REST API is to get evolvability â€¦ a &quot;v1&quot; is a middle finger to your API customers, indicating RPC/HTTP (not REST)</p>&mdash; Roy T. Fielding (@fielding) <a href="https://twitter.com/fielding/status/376835835670167552">September 8, 2013</a></blockquote>
<script async="" src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>Although GraphQL and REST can (and should) version via evolution just as easily, GraphQL really helps API developers out when it comes to deprecations.</p>

<h2 id="graphql-makes-deprecations-awesome">GraphQL makes Deprecations Awesome</h2>

<p>One area where GraphQL excels is to make monitoring field usage incredibly easy at a technical level. GraphQL clients are forced to specify the fields they want returned in the query:</p>

<pre class="highlight http"><code><span class="nf">POST</span> <span class="nn">/graphql</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Host</span><span class="p">:</span> <span class="s">localhost:3000</span>
<span class="na">Content-Type</span><span class="p">:</span> <span class="s">application/graphql</span>

{
  turtles(id: "123") {
    length,
    width,
    intelligence
  }
}
</code></pre>

<p>Tracking this would be trivial, but a REST API acts a little differently. Whilst all REST APIs make the base endpoint available via <code>/turtles/123</code>, not all APIs offer <a href="http://jsonapi.org/format/#fetching-sparse-fieldsets">sparse fieldsets</a>: <code>/turtles/123?fields=length,width,intelligence</code>. Of those that do offer it, it's almost always optional.</p>

<p>If a REST API client calls <code>/turtles/123</code>, then they could be using <em>any</em> field in that response. Imagine the API plans to get rid of <code>intelligence</code> (because <a href="https://en.wikipedia.org/wiki/Turtle#Intelligence">all turtles are geniuses</a>), how do the API developers know which clients are using that field?</p>

<p>An RPC approach is to make a new <code>/getTurtle2</code> endpoint (or <code>/v2/turtles/123</code> in a RPC API pretending to be a REST API), and tell people to use that new one.</p>

<p>One approach in REST APIs is to email warnings to whatever email address was entered when the client signed up for OAuth tokens (like Facebook previously did), maybe offering a feature flag so various clients can flip the switch when they are ready.</p>

<p>Another approach would be to create a new version of the resource, meaning instead of calling <code>GET</code> with <code>Accept: application/vnd.turtlefans.com+v1+json</code> they should start calling with <code>Accept: application/vnd.turtlefans.com+v2+json</code>.</p>

<p>All of the above approaches suffer the same issue, and that is that an entire version can be overkill for a simple change, and you might be forcing the developers to look into a version upgrade without needing to.</p>

<p>For example, if the client is requesting <code>application/vnd.turtlefans.com+v1+json</code> and the API is removing <code>intelligence</code> in v2, the API developers know not to drop v1 until the last of the clients are upgraded. Sadly, if clients are calling v1 <em>but not using the <code>intelligence</code> field, the API developers have no idea!</em> The API developers only know that the clients want v1, not what they're using of that v1 resource.</p>

<p>GraphQL makes it easy to track specific field usage to a client, meaning API owners can reach out to only those clients using fields that are heading out, or for internal projects you could have errors thrown in development/staging environments. I had a vague brain fart about doing this latter option for non-GraphQL HTTP APIs, but have not had a chance to see it through <em>yet</em>.</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">Thinking about a HTTP format for handling deprecations, because global and resource versioning is a PITA. Early draft <a href="http://t.co/KTqPhevVU8">pic.twitter.com/KTqPhevVU8</a></p>&mdash; Phil ðŸ¥‡ (@philsturgeon) <a href="https://twitter.com/philsturgeon/status/631588563524694016">August 12, 2015</a></blockquote>
<script async="" src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>That could help in some situations, but would certainly be baked into things the same way it is in GraphQL.</p>

<p><em>GraphQL making field deprecation easier was a point brought to my attention by <a href="https://twitter.com/itstomclark">Tom Clark</a>, super-smart Head of Devops at <a href="https://www.wework.com/">WeWork</a>.</em></p>

<h2 id="graphql-puts-client-performance-first">GraphQL Puts Client Performance First</h2>

<p>GraphQL is always the smallest possible request, whilst REST generally defaults to the fullest. It's common practice to offer options like <code>?fields=foo,bar</code> or partials. <a href="https://developers.google.com/google-apps/tasks/performance#partial">Google recommend doing this for HTTP APIs</a>, whatever that's worth.</p>

<p>Even if a REST API returns only a basic partial by default, there are still more bits being transferred over the wire by default, than with the GraphQL approach. If a client needs a field, they request it, and if the API adds a new field, clients don't get it, unless they discover that field in a blog post or whatever and add it to the GraphQL query.</p>

<h2 id="rest-makes-caching-easier-at-all-levels">REST Makes Caching Easier At All Levels</h2>

<p>Caching for HTTP, common usage in REST APIs, and different types of caching are huge topics, and something that I had to split out of this article. I'll post a followup shortly, which will be posted on the <a href="http://eepurl.com/biKG_v">APIs You Won't Hate Newsletter</a>.</p>

<blockquote>
  <p>In an endpoint-based API, clients can use HTTP caching to easily avoid refetching resources, and for identifying when two resources are the same. The URL in these APIs is a globally unique identifier that the client can leverage to build a cache. In GraphQL, though, there's no URL-like primitive that provides this globally unique identifier for a given object. It's hence a best practice for the API to expose such an identifier for clients to use.
â€“ Source: <a href="http://graphql.org/learn/caching/">graphql.org</a></p>
</blockquote>

<p>REST over HTTP uses a whole pile of HTTP conventions that make existing HTTP clients, HTTP cache proxies, etc., all work easily to benefit both API clients and API servers, but with GraphQLâ€¦ tough. Reorganize your data stores, use a bunch of Redis, and hope clients are caching too.</p>

<h2 id="graphql-is-a-query-language-first">GraphQL is a Query Language First</h2>

<p>A very fundamental difference here of course is that only one of these is a query language. REST APIs are often created initially simple, then slowly more and more query language-like features are tacked on over time.</p>

<p>The most reasonable way to provide arguments for queries in REST is to shove them in the query string. Maybe a <code>?status=active</code> to filter by status, then probably <code>sort=created</code>, but a client needs sort direction so <code>sort-dir=desc</code> is added.</p>

<p>Some APIs use also end up with arguments in the query string that are not related to filtering, more like options. In the GraphQL example they specify the unit they'd like to see a <code>height</code> returned in:</p>

<pre class="highlight plaintext"><code>{
  human(id: "1000") {
    name
    height(unit: FOOT)
  }
}
</code></pre>

<pre class="highlight json"><code><span class="p">{</span><span class="w">
  </span><span class="nt">"data"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nt">"human"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="nt">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Luke Skywalker"</span><span class="p">,</span><span class="w">
      </span><span class="nt">"height"</span><span class="p">:</span><span class="w"> </span><span class="mf">5.6430448</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre>

<p>That's pretty darn handy, and it stops the confusion of <code>?status=active</code> being a filter but <code>?unit=foot</code> being a display option. I have seen <code>?filter:status=active</code>, <code>?filter[status]=active</code>, etc., but this is still a bit of a mess.</p>

<p>In these scenarios, GraphQL beats the pants off of REST APIs that try to hand-roll their own query language functionality, but I would suggest hand-rolling your own query language is a bad idea anyway. GraphQL gives you a query language syntax, and SDKs for your programming language to fetch the right models for that, but so do things like <a href="http://www.odata.org/">OData</a>, a project with the slogan "A Better Way to REST".</p>

<p>This is another example of folks saying that REST cannot do something, just because many REST APIs don't do it, or because its implemented poorly by many that do. Saying that, remember that the more customisation an endpoint-based API adds to the request, the fewer cache hits are likely at a network caching level, making the REST/HTTP approach less rewarding, and forcing you down the route of the application caching and database reorganisation that GraphQL forces anyway.</p>

<p>If your API is highly customizable, it's another ticked box for considering GraphQL.</p>

<h2 id="graphql-removes-include-vs-endpoint-indecision">GraphQL Removes "Include vs Endpoint" Indecision</h2>

<p>Another customisation consideration that comes up a lot is when to offer included relationships, and when to use another endpoint. This can be a difficult design choice, as you want your API to be flexible and performant, but includes used past the most trivial uses can be the opposite of that.</p>

<p>You start off with overly simplistic examples like <code>/users?include=comments,posts</code> but end up on <code>/trips?include=driver,passengers,passengers.avatar,passengers.itineraries</code> and worse.</p>

<p>I call this the "Mega Include of DOOOOOOM", and it is crap solution to a genuine concern, when clients strive for performance over all else. Includes are a common convention found in REST APIs, recommended in specs like <a href="http://jsonapi.org/">JSON API</a>, but actually bends the rules of REST a bit.</p>

<p>REST would call for a HATEOAS approach, which would have you make one call to the <code>/trips</code> endpoint, then hit <code>"links": { "driver": "https://example.com/drivers/123" }</code>, and again for passengers, and again for child data of each of those passengers. In this case, it would be worse than the dreaded <code>n+1</code>, and more like <code>n+(2+(num passengers*2))</code>!</p>

<p>Includes start off with the best of intentions, but can grow to be a bottleneck in a REST API, with unwieldy queries happening against the data store. GraphQL not only removes this design question, but forces the include approach, and forces you to consider efficient means of fetching this data.</p>

<p>This is a big win for GraphQL, as forcing the include approach, and forcing efficient "Mega Includes of Doom", the GraphQL will be both efficient and consistent. Trying to make a REST API be include-only would be bizarre and unusable, so consistency will never work there.</p>

<p>GraphQL will not help with your database queries, so you still need to fine tune those indexes and cache fragments of the data intelligently. If you skip this, clients will surprise you. At a previous job we had a poorly-tuned mega include from the iOS app taking about 20s+ to respond, which was bloody terrifying. We almost just had them curl down a <code>latest.sqlite</code> to process locally. ðŸ¤£</p>

<h2 id="scoped-includes-suck-in-both">Scoped Includes Suck in Both</h2>

<p>Using that trip example again, a client may be including passengers but realize that includes historical passengers. Don't want to see people who left the carpool? The client has to iterate through passengers locally, removing any models where <code>model.status != "active"</code>, which is a waste of processing on the client side.</p>

<p>The REST way to do this would be to use <code>/passengers?trip=123&amp;status=active</code> which is obviously more flexible, but clients will skip this due to the extra requests required.</p>

<p>With client-side filtering being a poor choice, and the extra request not being ideal, REST API developers are often forced to add a new include: <code>/trips?include=activePassengers</code>. These are tough to pre-empt, so I was hoping GraphQL could help clients define their own scopes, filtering these includes to be the appropriate data themselves, which would help identify the scoped includes the API should add as convenience methods.</p>

<p>It seems like GraphQL doesn't help API developers in this instance, but there does seem to be talk of adding <code>@filter</code> to <a href="https://discuss.dgraph.io/t/filters-in-graphql/831/31">do this in the future</a>.</p>

<h2 id="graphql-devolves-power-to-clients">GraphQL Devolves Power to Clients</h2>

<p>Another question that comes up a lot for REST API developers, is:</p>

<blockquote>
  <p>Our iOS app, Android app and web app are very different from each other. How would we return different data for each client?</p>
</blockquote>

<p>We all start off trying to make our REST APIs so generic they can be used by anything, but as the mega-include problem indicated, clients want and need a lot, and they're always trying to reduce calls.</p>

<p>Some basic solutions for outputting different data per-client in a REST API are:</p>

<p><strong>Create custom endpoints:</strong> <code>/iphone_snapshot</code>. We've done this at a past company where the mobile data was completely different to anything else. It felt dirty, was almost definitely RPC, but it got the job done. Having the supposedly generic REST API know so much about a specific client defeats the purpose a little bit, but we needed to get the data to the iPhone and that was what happened.</p>

<p><strong>Create custom representations:</strong> Using <code>Content-Type: application/vnd.turtlefans.com+v1+iphone+json</code> which had its own custom serializer would supposedly be a bit more REST in that it's just another representation, but equally odd.</p>

<p><strong>Custom APIs!</strong> This concept was/is in use by Netflix if I remember rightly, and the idea is to have one API for each of their clients. There is an Android REST API, a iOS REST API, Web REST API, etc. Each of these is tailored to perfectly match the needs of their specific teams, and makes requests back to the central Generic REST API. Requiring multiple APIs, multiple development teams, etc, is certainly out of the reach of many organizations, but it does solve the issue nicely.</p>

<p>Orâ€¦ <strong>GraphQL!</strong> Instead of making custom endpoints, custom representations, or custom APIs, the clients simply write their own queries. This moves the responsibility out of the hands of the API developers, and into the clients, who then get to write in their language of choice, instead of bugging the API team to write it in a different language.</p>

<p>Whether you need this paradigm shift or not is entirely up to how similar your clients are. If you're a private/internal API and your clients are all practically identical, then you certainly don't want them all handling things.</p>

<p>But, if you have a multitude of different clients, or are public (therefore have no idea how the API will be used), GraphQL quickly starts to seem more appealing.</p>

<h2 id="why-not-use-both">Why Not Use Both?</h2>

<p>The biggest oddity I notice in the "GraphQL vs REST" conversation, is the falsehood that <em>you must pick one</em>.</p>

<p>In a world of SoA, you are likely to have multiple services, which expose multiple APIs. In the <a href="https://www.smashingmagazine.com/2016/09/understanding-rest-and-rpc-for-http-apis/">RPC vs REST article</a> I point out that some services might be REST and some might be RPC, and you can absolutely throw some GraphQL in with your REST.</p>

<p>One mix of REST and GraphQL could just be adding a <code>/graphql</code> endpoint to <code>api.whatever.com</code> and having that as your GraphQL endpoint on an REST API.</p>

<p>Another, is one that has been vaguely tossed around at work, which is the idea of having one GraphQL API, acting as a gateway to our other multiple REST APIs.</p>

<p>Having one GraphQL server act as a sort of data proxy, giving one entry point for mixed data, one Authentication scheme despite each REST API having its own "unique" approach to tokens, one HTTP call for clients - despite it hitting multiple actual REST APIs, etc., would be a damn powerful thing.</p>

<h2 id="summary">Summary</h2>

<p>Ask yourself - at the very least - these following questions:</p>

<ul>
  <li>
    <p>How different are your clients from each other?</p>
  </li>
  <li>
    <p>Do you trust your clients to handle caching?</p>
  </li>
  <li>
    <p>Do you want "dumb clients" that act like crawlers - knowing very little about the API, or clients that own a lot of the logic and know a lot about the API, using it simply as a data transfer?</p>
  </li>
  <li>
    <p>Are you ok letting go of HTTP debugging proxies, cache proxies, all the knowledge your team have around HTTP, etc?</p>
  </li>
  <li>
    <p>Are you just doing basic CRUD with simple JSON documents, or will your API need file upload/download too?</p>
  </li>
</ul>

<p>If your REST API is following good practices, like allowing careful <a href="https://www.mnot.net/blog/2012/12/04/api-evolution">evolution</a> instead of <a href="https://www.troyhunt.com/your-api-versioning-is-wrong-which-is/">global versioning</a>, <a href="/api/2015/05/30/serializing-api-output/">serializing data</a> instead of returning directly from data store, implementing <a href="http://jsonapi.org/format/#fetching-sparse-fieldsets">sparse fieldsets</a> to allow slimming down response sizes, <a href="http://checkgzipcompression.com/">GZiping contents</a>, outlining data structures with <a href="http://json-schema.org/">JSON Schema</a>, offering <a href="http://blog.codeclimate.com/blog/2014/06/05/choose-protocol-buffers/">binary alternatives to JSON like Protobuff</a> or BSON, etc., then the advertised advantages of GraphQL seem to fall a bit short.</p>

<p>If you need a highly query-able API, expect an array of clients that need small and different data, and can restructure your data to be inexpensive to query, then GraphQL is likely to fit your needs.</p>

<p>Beyond these various pros and cons for GraphQL listed above, what I really enjoy about GraphQL being an option, is having a new alternative to REST when considering an API. An alternative that is well documented, with a full specification, with a lovely marketing page, with an official reference implementation in JavaScript, and which avoids some of the tricky design choices REST forces you to make.</p>

<p>I like that many folks will no longer treat REST like a shiny unicorn, struggle to implement REST properly, then call it REST just so they look good and have a âœ… for their marketing. I just hope that not too many people treat GraphQL like a shiny unicorn instead.</p>

<p>Swapping one false idol for another isn't going to make the API world a better place.</p>

          <hr>
<p>More on GraphQL:</p>
<ul>
  <li>
    <a href='/api/2017/01/24/graphql-vs-rest-overview/'>GraphQL vs REST: Overview</a>
  </li>
  <li>
    <a href='/api/2017/01/26/graphql-vs-rest-caching/'>GraphQL vs REST: Caching</a>
  </li>
  <li>
    <a href='/api/2017/04/18/you-might-not-need-graphql/'>You Might Not Need GraphQL</a>
  </li>
  <li>
    <a href='/api/2017/06/19/representing-state-in-rest-and-graphql/'>Representing State in REST and GraphQL</a>
  </li>
</ul>
<p>
  <em>If you appreciate these articles and want me to keep them coming, fire some coins over. Maybe I'll even run the next one through a spell checker.</em>
</p>
<p>
  <em>
    <strong>bitcoin</strong> - 1PNbuCjgATjaaHtq7zZKqe3FBL7ngyDi23<br/>
    <strong>etherium</strong> - 0x507d6E943885a5AeD76Fa3C43dB5C73a0f1Dc792
  </em>
</p>

        </section>
        <footer class="post-footer">
            <section class="share">
            </section>
            <section class="post-next-previous">
                <p>
                    Previous:
                    <a class="button" href="/api/2017/01/03/building-apis-with-rails-handling-errors-nicely/">Building APIs with Rails: Handling Errors Nicely</a>
                </p>
                <p style="float:right">
                    Next:
                    <a class="button" href="/api/2017/01/26/graphql-vs-rest-caching/">GraphQL vs REST: Caching</a>
                </p>
            </section>
        </footer>
        <div class="bottom-teaser cf">
          <div class="more isLeft">
            <h5 class="index-headline featured"><span>Written by</span></h5>
            <section class="author">
              <div class="author-image" style="background-image: url(/images/author.jpg)">Blog Logo</div>
              <h4>Phil Sturgeon</h4>
              <p class="bio">Platform Engineer @ WeWork who talks about APIs a lot. Programming Polyglot, Pragmatist, Centerist and Sarcasist. Ex-The League of Extraordinary Packages, PHP The Right Way, Ex-PHP-FIG, Ex-CodeIgniter, Ex-FuelPHP, Ex-PyroCMS.</p>
            </section>
          </div>
          <div class="more isRight">
            <h5 class="index-headline featured"><span>More Writing</span></h5>
            <section class="author">
              <a href="http://apisyouwonthate.com/">
                <div class="book-image build-apis">Book Cover</div>
                <h4>Build APIs You Won't Hate</h4>
              </a>
              <p class="bio">Everyone and their dog wants an API, so you should probably learn how to build them.</p>
              <p><a href="http://apisyouwonthate.com/">Buy it from LeanPub or Amazon</a>.</p>
            </section>
          </div>
        </div>
      </article>

      <div id="disqus_thread"></div>
      <script type="text/javascript">
          /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
          var disqus_shortname = 'philsturgeon';


          /* * * DON'T EDIT BELOW THIS LINE * * */
          (function() {
              var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
              dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
              (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
          })();
      </script>
      <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

    </main>
    <div class="bottom-closer">
      <div class="background-closer-image" style="background-image: url(/images/cover.jpg)">
        Image
      </div>
      <div class="inner">
        <h1 class="blog-title">Phil Sturgeon</h1>
        <h2 class="blog-description">Platform Engineer @ WeWork who talks about APIs a lot. Programming Polyglot, Pragmatist, Centerist and Sarcasist. Ex-The League of Extraordinary Packages, PHP The Right Way, Ex-PHP-FIG, Ex-CodeIgniter, Ex-FuelPHP, Ex-PyroCMS.</h2>
        <a href="/" class="btn">Back to Overview</a>
      </div>
    </div>

    <!-- content end -->

    <footer class='footer' role='contentinfo'>
  <div class='footer-links'>
    <ul class='context'>
      <li>
        <h3>Content</h3>
      </li>
      <li>
        <a href='/about'>About</a>
      </li>
      <li>
        <a href='/books'>Books</a>
      </li>
      <li>
        <a href='/speaking'>Speaking</a>
      </li>
    </ul>
    <ul class='follow'>
      <li>
        <h3>Follow Me</h3>
      </li>
      <li>
        <a href='https://twitter.com/philsturgeon'>Twitter</a>
      </li>
      <li>
        <a href='https://github.com/philsturgeon'>GitHub</a>
      </li>
      <li>
        <a href='http://apibusters.com/'>API Busters Podcast</a>
      </li>
      <li>
        <a href='http://phil.bike/'>Phil.Bike</a>
      </li>
    </ul>
    <ul class='recent_posts'>
      <li>
        <h3>Recent Posts</h3>
        <ul>
          <li><a href="/api/2018/04/13/openapi-and-json-schema-divergence-solved/">OpenAPI and JSON Schema Divergence: Part 2</a></li>
          <li><a href="/api/2018/03/30/openapi-and-json-schema-divergence/">OpenAPI and JSON Schema Divergence: Part 1</a></li>
          <li><a href="/api/2018/03/01/api-specification-workflow-matures/">Design-first API Specification Workflow Matures</a></li>
        </ul>
      </li>
    </ul>
  </div>
</footer>

    <script src="//code.jquery.com/jquery-1.11.3.min.js"></script>
<script src="/javascripts/jquery.fitvids.js"></script>
<script src="/javascripts/index.js"></script>
<script src="/javascripts/readingTime.min.js"></script>
<script>
(function ($) {
  "use strict";
  $(document).ready(function(){

    var $window = $(window),
    $image = $('.post-image-image, .teaserimage-image');
    $window.on('scroll', function() {
      var top = $window.scrollTop();

      if (top < 0 || top > 1500) { return; }
      $image
        .css('transform', 'translate3d(0px, '+top/3+'px, 0px)')
        .css('opacity', 1-Math.max(top/700, 0));
    });
    $window.trigger('scroll');

    var height = $('.article-image').height();
    $('.post-content').css('padding-top', height + 'px');

    $('a[href*=#]:not([href=#])').click(function() {
      if (location.pathname.replace(/^\//,'') == this.pathname.replace(/^\//,'')
       && location.hostname == this.hostname) {
        var target = $(this.hash);
        target = target.length ? target : $('[name=' + this.hash.slice(1) +']');
        if (target.length) {
          $('html,body').animate({ scrollTop: target.offset().top }, 500);
          return false;
        }
      }
    });
  });
}(jQuery));
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-8523256-1', 'auto');
  ga('send', 'pageview');

</script>


  </body>

</html>
